## RFC: Инкрементальные обновления переводов (i18n)

### Статус

- Draft

### Контекст

Текущая реализация i18n загружает полный словарь переводов для языка. Это неэффективно при частых небольших изменениях: передаётся лишний объём данных, а клиенты получают устаревшие переводы до полной перезагрузки словаря.

### Цели

- Ввести версионирование словарей переводов и поддержать инкрементальные обновления (патчи).
- Свести к минимуму передаваемый трафик: клиент, имея версию N, запрашивает патч до последней версии M и применяет его без полной перезагрузки.
- Обеспечить обратную совместимость с текущим API `createI18n`.

### Не цели

- Изменение формата хранения всех переводов на сервере.
- Введение сложной дифф-логики (на первом этапе только добавление/замена значений по ключам; удаление — отдельным этапом/флагом).

### Термины

- Версия словаря языка — монотонно растущий целочисленный счётчик изменений для конкретного языка.
- Cookie `lasti18n` — строка в формате `<lang>:<version>` (например, `ru:10`), отражающая последнюю известную клиенту версию активного языка.
- Патч (Patch) — инкрементальное обновление вида: «из версии X перейти на версию Y», содержащее изменения для заданного языка.

### Модель версий и cookie

Версия отслеживается отдельно для каждого языка и является целым числом `version ∈ N, version ≥ 0`, увеличивается на 1 при каждом изменении словаря языка.

Cookie `lasti18n` хранит последнюю известную версию активного языка: `<lang>:<version>`.

- Примеры: `ru:10`, `en:0`.
- Если куки отсутствует — считаем версию равной 0 (или значение, переданное сервером при SSR).
- При смене активного языка клиент может записать/обновить `lasti18n` для нового языка после успешной загрузки актуальной версии.

Требования к совместимости:

- Поддержать существующие клиенты без куки: логика должна корректно работать, начиная с полной загрузки и последующего патчинга.
- Куки должны быть компактными и не хранить несколько языков (минимальный первый этап). Расширение до мульти-языка возможно последующей версией (`lasti18n=ru:10|en:7`).

SSR:

- На SSR сервер проставляет актуальную пару `<lang>:<version>` в Set-Cookie (или в HTML встраивает `data-i18n-version`, откуда клиент запишет куку при гидратации).
- Клиент при инициализации использует значение из куки (или встроенное значение) как базу.

### Формат патча и серверные эндпоинты

Патч описывает переход из версии `from` к версии `to` для конкретного языка. Минимальный формат:

```json
{
  "lang": "ru",
  "from": 10,
  "to": 12,
  "data": { "key": "value" }
}
```

Семантика:

- `data` содержит пары ключ → новое значение строки для данного языка.
- Добавление нового ключа: просто присутствует в `data`.
- Замена значения существующего ключа: присутствует в `data`, старое значение перезаписывается.
- Удаления: на первом этапе не поддерживаются (опционально `null` как маркер удаления в будущем).

Серверный API (минимум):

- GET `/i18n/patch?lang=<lang>&from=<version>` → возвращает патч до последней версии.
  - Если `from` равен последней версии — сервер возвращает `204 No Content` или `{"lang","from","to":from,"data":{}}`.
  - Сервер может агрегировать несколько изменений сразу: `to >= from`.
  - Ответ должен быть кэшируемым и иметь `ETag`/`Cache-Control`.

Опционально:

- HEAD `/i18n/version?lang=<lang>` → возвращает только номер текущей версии для быстрой проверки.

### Изменения клиентского API i18n

Добавить поддержку версий и патчей без ломающих изменений:

- Новые опции `createI18n`:
  - `getCurrentVersion?: (lang: Lang) => Promise<number> | number` — узнать текущую серверную версию.
  - `getPatch?: (lang: Lang, from: number) => Promise<{from:number; to:number; data: Record<string,string>}>` — получить патч.
  - `onVersionChange?: (lang: Lang, to: number) => void` — обратный вызов для записи куки `lasti18n`.
  - `initialVersion?: number` — стартовая известная версия (например, из SSR/куки).
  - `versionStore?: { get(lang: Lang): number | undefined; set(lang: Lang, v: number): void }` — абстракция хранения версии (по умолчанию — куки).

- Новые методы возвращаемого объекта:
  - `getVersion(): number` — текущая версия активного языка.
  - `sync(): Promise<void>` — запросить и применить патч для активного языка (если отстаём). Для этого может понадобиться конфигурация эндпоинта синхронизации во время создания фабрики. Лучше во время создания фаблики задавать промис который должен возвращать патч.

- Поведение:
  - При инициализации: если задан `getCurrentVersion` и/или `getPatch`, клиент проверяет рассинхронизацию и, при необходимости, применяет патч.
  - При смене языка `setLang`: аналогично инициируется проверка и возможный патч. (если клиент не перезагружает все приложение при смене языка)
  - При успешном применении патча: обновляется внутренняя версия и вызывается `onVersionChange`.

### Алгоритм применения патча и инвалидация кэша

1) Определение актуальности: сравнить локальную версию `v_local` и серверную `v_server`.
2) Если `v_server > v_local`: запросить патч `getPatch(lang, v_local)`.
3) Проверить согласованность: `patch.from === v_local`, `patch.to >= patch.from`.
4) Применить `data` к внутреннему стору переводов только для данного языка: для каждого `key` выполнить добавление/перезапись.
5) Обновить `v_local = patch.to` и сохранить через `versionStore.set`.
6) Инвалидировать LRU-кэш форматированных строк только для активного языка (сброс соответствующих ключей).
7) Никаких побочных эффектов вне i18n (кроме `onVersionChange`).

Edge-cases:

- Пустой патч (`from == to` или `data = {}`) — ничего не менять, но можно обновить куку.
- Несогласованный патч (`from != v_local`) — запросить свежую версию (`getCurrentVersion`) и повторить цикл или сделать полную перезагрузку.
- Отсутствие сетевого доступа — оставляем локальную версию и словарь без изменений.

### SSR и инициализация

SSR должен отдать актуальный словарь и версию активного языка. Если не установлена и на клиенте еще нет необходимых данных, иначе в разметку вставляется патч. Клиент при гидратации принимает `initialVersion` и при первой возможности сверяет версию с сервером. Если SSR и клиент совпадают — патч не нужен.

### Совместимость и план миграции

Этап 1 (минимальный):

- Поддержка версий и патчей только для активного языка, без удалений.
- Куки `lasti18n` в формате `<lang>:<version>`.
- Бэкенд предоставляет `/i18n/patch` и, опционально, `/i18n/version`.

Этап 2 (расширение):

- Поддержка нескольких языков в куке (`ru:10|en:7`).
- Маркеры удаления и GC «мертвых» ключей.
- Бандлинг нескольких патчей и дедупликация.

### Тест-план (WTR)

Покрытие ключевых сценариев, переиспользуя фикстуры из `tools/tests/fixtures`:

- Инициализация без куки: загрузка словаря, запись `lasti18n`.
- Инициализация с кукой (`ru:10`) и сервером `to=12`: применён патч, версия стала 12, строки доступны.
- Пустой патч (`from == to`): нет изменений, версия сохраняется.
- Смена языка: проверка патча для нового языка, независимые версии.
- Инвалидация кэша форматированных строк после патча.
- Ошибка сети/сервер возвращает несогласованный патч: не меняем стор, повторная синхронизация позже.
- SSR: `initialVersion` совпадает — патч не запрашивается.

### Риски, ограничения и открытые вопросы

- Поведение при одновременном обновлении нескольких языков (пока вне области RFC-1).
- Как обрабатывать удаления и реорганизацию ключей?
- Версионирование на уровне ключей vs на уровне языка — текущее решение язык-уровень.
- Политика кэширования и срока жизни патча (stale-while-revalidate?).
- Безопасность и подпись патча/верификация источника.

### Примеры

Исходные условия: клиент имеет `lasti18n=ru:10`, сервер — `ru` v12.

Запрос клиента: GET `/i18n/patch?lang=ru&from=10` →

```json
{
  "lang": "ru",
  "from": 10,
  "to": 12,
  "data": {
    "newKey": "Tam",
    "newKey2": "Tam2"
  }
}
```

Клиент применяет патч, обновляет локальное хранилище строк и выставляет `lasti18n=ru:12`.
